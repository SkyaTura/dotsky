# Path to oh-my-zsh installation.
export ZSH="$HOME/.oh-my-zsh"

export NVM_DIR="$HOME/.nvm"
export NVM_HOMEBREW="/usr/local/opt/nvm"

export PATH="$PYENV_ROOT/bin:$PATH"
export PATH="$HOME/.local/bin:$PATH"
export PATH="$HOME/bin:$PATH"
export PATH="$HOME/.cargo/bin:$PATH"

export PATH="$HOME/dotconfig/bin:$PATH"
export IDF_PATH=/Users/skyatura/esp/esp-idf-v4.0

source "$HOME/.antigen.zsh"

antigen bundle zuxfoucault/colored-man-pages_mod
antigen bundle zsh-users/zsh-syntax-highlighting
antigen bundle zpm-zsh/colorize

antigen apply

ZSH_THEME="skyatura"

ENABLE_CORRECTION="true"

COMPLETION_WAITING_DOTS="true"

DISABLE_UNTRACKED_FILES_DIRTY="true"

export HELM_EXPERIMENTAL_OCI=1

plugins=(
  aliases
  git
  brew
  common-aliases
  sudo
  # pyenv
  nvm
  z
)

DEFAULT_USER="skyatura"

# Setting rg as the default source for fzf
export FZF_DEFAULT_COMMAND='rg --files'

# Apply the command to CTRL-T as well
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"

# Set default editor to nvim
export EDITOR='lvim'

# Enabled true color support for terminals
export NVIM_TUI_ENABLE_TRUE_COLOR=1

export PATH="/usr/local/opt/ruby/bin:$PATH"

# Load ruby packages
for D in `find "$HOME/.gem/ruby" -type d -mindepth 1 -maxdepth 1`
do
  PATH=$PATH:$D/bin
done

export LANG="pt_BR.UTF-8"
export LC_COLLATE="pt_BR.UTF-8"
export LC_CTYPE="pt_BR.UTF-8"
export LC_MESSAGES="pt_BR.UTF-8"
export LC_MONETARY="pt_BR.UTF-8"
export HOMEBREW_PREFIX="/opt/homebrew";
export HOMEBREW_CELLAR="/opt/homebrew/Cellar";
export HOMEBREW_REPOSITORY="/opt/homebrew";
export PATH="/opt/homebrew/bin:/opt/homebrew/sbin${PATH+:$PATH}";
export MANPATH="/opt/homebrew/share/man${MANPATH+:$MANPATH}:";
export INFOPATH="/opt/homebrew/share/info:${INFOPATH:-}";
export LC_NUMERIC="pt_BR.UTF-8"
export LC_TIME="pt_BR.UTF-8"
export LC_ALL="pt_BR.UTF-8"


## NVM Settings

zstyle ':omz:plugins:nvm' lazy yes
zstyle ':omz:plugins:nvm' lazy-cmd eslint prettier typescript tsc gitmoji ncu nx npx

nvm_echo () {
  command printf %s\\n "$*" 2> /dev/null
}

nvm_find_up () {
  local path_
  path_="${PWD}"
  while [ "${path_}" != "" ] && [ ! -f "${path_}/${1-}" ]
  do
    path_=${path_%/*}
  done
  nvm_echo "${path_}"
}

nvm_find_nvmrc () {
  local dir
  dir="$(nvm_find_up '.nvmrc')"
export HOMEBREW_PREFIX="/opt/homebrew";
export HOMEBREW_CELLAR="/opt/homebrew/Cellar";
export HOMEBREW_REPOSITORY="/opt/homebrew";
export PATH="/opt/homebrew/bin:/opt/homebrew/sbin${PATH+:$PATH}";
export MANPATH="/opt/homebrew/share/man${MANPATH+:$MANPATH}:";
export INFOPATH="/opt/homebrew/share/info:${INFOPATH:-}";
  if [ -e "${dir}/.nvmrc" ]
  then
    nvm_echo "${dir}/.nvmrc"
  fi
}

# Autoload nvm when finding a .nvmrc file in the current directory
# Adapted from: https://github.com/nvm-sh/nvm#zsh
function load-nvmrc {
  # If nvm is not installed, do nothing
  if [[ ! -f "$NVM_DIR/nvm.sh"  ]]; then
    return
  fi

  local nvmrc_path="$(nvm_find_nvmrc)"

  # If there is no .nvmrc and nvm is not loaded yet, do nothing
  if [ -z "$nvmrc_path" ]; then
    which nvm &>/dev/null || return
  # Else if there is a .nvmrc, but nvm is not loaded yet
  elif ! (which nvm &>/dev/null); then
    source "$NVM_DIR/nvm.sh"
  fi

  local node_version="$(nvm version)"
  local nvm_silent=""
  zstyle -t ':omz:plugins:nvm' silent-autoload && nvm_silent="--silent"

  if [[ -n "$nvmrc_path" ]]; then
    local nvmrc_node_version=$(nvm version $(cat "$nvmrc_path" | tr -dc '[:print:]'))

    if [[ "$nvmrc_node_version" = "N/A" ]]; then
      nvm install
    elif [[ "$nvmrc_node_version" != "$node_version" ]]; then
      nvm use $nvm_silent
    fi
  elif [[ "$node_version" != "$(nvm version default)" ]]; then
    if [[ -z $nvm_silent ]]; then
      echo "Reverting to nvm default version"
    fi

    nvm use default $nvm_silent
  fi
}

SPACESHIP_TIME_SHOW=true
SPACESHIP_GCLOUD_SHOW=false
SPACESHIP_NODE_SHOW=true
SPACESHIP_EXIT_CODE_SHOW=true
SPACESHIP_BATTERY_SHOW=true
SPACESHIP_BATTERY_THRESHOLD=30
SPACESHIP_CHAR_PREFIX="%{$fg_bold[green]%}lyniela "
SPACESHIP_PROMPT_ORDER=(
  time           # Time stamps section
  user           # Username section
  dir            # Current directory section
  host           # Hostname section
  git            # Git section (git_branch + git_status)
  package        # Package version
  node           # Node.js section
  bun            # Bun section
  deno           # Deno section
  python         # Python section
  rust           # Rust section
  lua            # Lua section
  docker         # Docker section
  docker_compose # Docker section
  venv           # virtualenv section
  zig            # Zig section
  kubectl        # Kubectl context section
  nix_shell      # Nix shell
  gnu_screen     # GNU Screen section
  exec_time      # Execution time
  async          # Async jobs indicator
  line_sep       # Line break
  battery        # Battery level and status
  jobs           # Background jobs indicator
  exit_code      # Exit code section
  sudo           # Sudo indicator
  char           # Prompt character
)


source "/usr/local/opt/spaceship/spaceship.zsh"
source "$ZSH/oh-my-zsh.sh"

################### My aliases
#
#
#
## FZF FUNCTIONS ##

# fo [FUZZY PATTERN] - Open the selected file with the default editor
#   - Bypass fuzzy finder if there's only one match (--select-1)
#   - Exit if there's no match (--exit-0)
fo() {
  local files
  IFS=$'\n' files=($(fzf-tmux --query="$1" --multi --select-1 --exit-0))
  [[ -n "$files" ]] && ${EDITOR:-vim} "${files[@]}"
}

# fh [FUZZY PATTERN] - Search in command history
fh() {
  print -z $( ([ -n "$ZSH_NAME" ] && fc -l 1 || history) | fzf +s --tac | sed 's/ *[0-9]* *//')
}

# fbr [FUZZY PATTERN] - Checkout specified branch
# Include remote branches, sorted by most recent commit and limited to 30
fgb() {
  local branches branch
  branches=$(git for-each-ref --count=30 --sort=-committerdate refs/heads/ --format="%(refname:short)") &&
  branch=$(echo "$branches" |
           fzf-tmux -d $(( 2 + $(wc -l <<< "$branches") )) +m) &&
  git checkout $(echo "$branch" | sed "s/.* //" | sed "s#remotes/[^/]*/##")
}

alias gcf='git checkout $(git branch -a | fzf -e)'
alias glmr='npm run createMR'

# fuzzy grep via rg and open in vim with line number
fgr() {
  local file
  local line

  read -r file line <<<"$(rg --no-heading --line-number $@ | fzf -0 -1 | awk -F: '{print $1, $2}')"

  if [[ -n $file ]]
  then
     vim $file +$line
  fi
}

alias get_idf='. $HOME/esp/esp-idf-v4.0/export.sh'
alias gck='git checkout'
alias vim='lvim'
alias v='lvim'
alias ni='npm install'
alias nif='npm install --force'
alias nil='npm install --legacy-peer-deps'
alias nrn='rm -rf node_modules'
alias nri='nrn && ni'
alias nrif='nrn && nif'
alias nril='nrn && nil'
alias nis='ni --save'
alias nid='ni --save-dev'
alias nifs='nif --save'
alias nifd='nif --save-dev'
alias nils='nil --save'
alias nild='nil --save-dev'
alias nig='ni -g'
alias nrd='npm run dev'
alias nrb='npm run build'
alias nrs='npm start'
alias nrt='npm run test'
alias top='vtop --theme=wizard'
alias l='colorls -lA --sd'
alias gc='gitmoji -c'
alias brew='env PATH="${PATH//$(pyenv root)\/shims:/}" brew'
alias useAllynnaD='export DOCKER_HOST="ssh://skyatura@10.10.3.3"'
alias useAllynnaDL='export DOCKER_HOST="ssh://skyatura@192.168.2.6"'
alias useAllynna='useAllynnaD; rfs-ar &'
alias useAllynnaL='useAllynnaDL; rfs-al &'
alias useLocalD='unexport DOCKER_HOST'
alias adocker='DOCKER_HOST="ssh://skyatura@10.10.3.3" docker'
alias adocker-compose='DOCKER_HOST="ssh://skyatura@10.10.3.3" docker-compose'
alias aldocker='DOCKER_HOST="ssh://skyatura@192.168.2.6" docker'
alias aldocker-compose='DOCKER_HOST="ssh://skyatura@192.168.2.6" docker-compose'
alias drit='docker run --rm -it'
alias icat="kitty +kitten icat"
alias s="kitty +kitten ssh"

# Set allynna as default docker
export DOCKER_HOST="ssh://skyatura@10.10.3.3"

gac() {
  git add $@
  gitmoji -c
  git push
}

function transX() {
  all_args=("$@")
  from=$1
  to=$2
  rest_args=("${all_args[@]:2}")
  text=("${rest_args[@]}")

  trans -from $from -to $to "$text"
}

function transP() {
  all_args=("$@")
  from=$1
  to=$2
  rest_args=("${all_args[@]:2}")
  text=("${rest_args[@]}")

  trans -b -p -from $from -to $to "$text"
}

function tpe() {
  transX pt en $@
  transP pt en $@
}

function tep() {
  transX en pt $@
  transP en pt $@
}

function ptouch() {
  for p do
    _dir="$(dirname -- "$p")"
    mkdir -p -- "$_dir" &&
      touch -- "$p"
  done
}

alias sb='bash -c ''cd ~/soundboard && afplay "$(fzf)"'''
function sbd() {
  sb
  sbd
}

fpath+=${ZDOTDIR:-~}/.zsh_functions

# bun completions
[ -s "/Users/skyatura/.bun/_bun" ] && source "/Users/skyatura/.bun/_bun"

# bun
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"

# export PYENV_ROOT="$HOME/.pyenv"
# export PATH="$PYENV_ROOT/bin:$PATH"
# eval "$(pyenv init --path)"

touch "$HOME/.zshrc.local"
source "$HOME/.zshrc.local"
